
* git internal <2016-03-29 周二 11:19>

** understanding git
git is a content tracker, it tracks content - files and directories.
It is at its heart a collection of simple tools that implement a tree history STORAGE AND DIRECTORY CONTENT MANAGEMENT SYSTEM.
GIT好像一个文件系统，它追踪目录及文件的变化
#+BEGIN_QUOTE
IN MANY WAYS YOU CAN JUST SEE GIT AS A FILESYSTEM - IT'S CONTENT-ADDRESSABLE, AND IT HAS A NOTION OF VERSIONING, BUT I REALLY REALLY DISIGNED IT COMING AT THE PROBLEM FROM THE VIEWPOINT OF A FILESYSTEM PERSON (HEY, KERNELS IS WHAT I DO), AND I ACTUALLY HAVE ABSOLUTELY ZERO INTEREST IN CREATING A TRADITIONAL SCM SYSTEM -- LINUS
#+END_QUOTE


MOST SCMS STORE A NEW VERSION OF A PROJECT WITH CODE DELTA OR DIFF.
GIT STORES A NEW VERSION OF A PROJECT, IT STORES A NEW TREE - A BUNCH OF BLOBS OF CONTENT AND A COLLECTION OF POINTERS THAT CAN BE EXPANDED BACK OUT INTO A FULL DIRECTORY OF FILES AND SUBDIRECTORIES.
IF YOU WANT A DIFF BETWEEN TWO VERSIONS, IT DOESN'T ADD UP ALL THE DELTAS, IT SIMPLY LOOKS AT THE TWO TREES AND RUNS A NEW DIFF ON THEM.
大多数SCMS保存新版本时，保存代码的变化部分；GIT保存一棵新的树，包含了新版本的文件的内容和一些文件的指针。当你需要比较版本时，它读出不同版本的文件，并运行DIFF返回结果。
这就是GIT使分布式更容易的基础。合并一系列复杂的变化对它来说不是个问题，他直接返回特定版本的所有内容，不需要进行代码变化的合并。

THERE ARE A NUMBER OF AREAS THAT THE DEVELOPERS OF GIT, INCLUDING AND ESPECIALLY LINUS, HAVE FOCUSED ON IN CONCEIVING(CONCEIVE V. 构想 设想 想象 构思 怀孕) AND BUILDING GIT.
THERE MAY BE A LOT OF THINGS THAT GIT IS NOT GOOD AT, BUT THESE THINGS ARE WHAT GIT IS VERY GOOD AT.

+ NON-LINEAR DEVELOPEMENT
  GIT IS OPTIMIZED FOR CHEAP AND EFFICIENT BRANCHING AND MERGING.
  GIT IS BUILT TO BE WORKED ON SIMULTANEOUSLY BY MANY PEOPLE, HAVING MYLTIPLE BRANCHES DEVELOPED BY INDIVIDUAL DEVELOPERS, BEING MERGED, BRANCHED AND RE-MERGED CONSTANTLY. BECAUSE OF THIS, BRANCHING IS INCREDIBLY CHEAP AND MERGING IS INCREDIBLY EASY.

+ DISTRIBUTED DEVELOPMENT
  GIT IS BUILT TO MAKE DISTRIBUTED DEVELOPMENT SIMPLE. NO REPOSITORY IS SPECIAL OR CENTRAL IN GIT -EACH CLONE IS BASICALLY EQUAL AND COULD GENERALLY REPLACE ANY OTHER ON AT ANY TIME. IT WORKS COMPLETELY OFFLINE OR WITH HUNDREDS OF REMOTE REPOSITORIES THAT CAN PUSH TO AND/OR FETCH FROM EACH OTHER OVER SEVERAL SIMPLE AND STANDARD PROTOCOLS.

+ EFFICIENCY
  GIT IS VERY EFFICIENT. MOST OPERATIONS ARE LOCAL, WHICH REDUCES UNNECESSARY NETWORK OVERHEAD. REPOSITORIES ARE GENERALLY PACKED VERY EFFICIENTLY, WHICH OFTEN LEADS TO SURPRISINGLY SMALL REPO SIZES.
  GIT ALSO IS EFFICIENT IN ITS NETWORK OPERATIONS - THE COMMON GIT TRANSFER PROTOCOLS TRANSFER ONLY PACKED VERSIONS OF ONLY THE OJBECTS THAT HAVE CHANGED. IT ALSON WON'T TRY TO TRANSFER CONTENT TWICE, SO IF YOU HAVE THE SAME FILE UNDER TWO DIFFERENT NAMES, IT WILL ONLY TRANSFER THE CONTENT ONCE.


** A TOOLKIT DESIGN
GIT IS DESIGNED AS A TOOLKIT THAT CAN BE COMBINED AND CHAINED TO DO NEW AND INTERESTING THINGS.
THE TOOLS CAN BE MORE OR LESS DIVIDED INTO TWO MAJOR CAMPS, OFTEN REFERED TO AS THE PORCELAIN AND THE PLUMBING.

+ PORCELAIN (PORCELAIN N. 瓷 瓷器; ADJ. 脆的 易碎的 精美的 瓷的)
  THE USER-ORIENTED INTERFACES TO DO SCM TYPE THINGS - HIDING THE LOW-LEVEL FUN.

+ PLUMBING (PLUMBING N. 建筑物的管路系统，水暖工的工作，管道 水管设施; V. PLUMB 的分词)
  TO DO SIMPLE THINGS FLEXIBLY AND ARE COMBINED BY PROGRAMS AND SCRIPTS INTO PORCELAIN PROGRAMS.


** GIT OBJECT TYPES
GIT OBJECTS ARE THE ACTUAL DATA OF GIT, THE MAIN THING THAT THE REPOSITORY IS MADE UP OF. THERE ARE FOUR MAIN OBJECT TYPES IN GIT, THE FIRST THREE BEING THE MOST IMPORTANT TO REALLY UNDERSTAND THE MAIN FUNCTIONS OF GIT

ALL OF THESE TYPES OF OBJECTS ARE STORED IN THE GIT *OBJECT DATABASE*, WHICH IS KEPT IN THE *GIT DIRECTORY*. EACH OBJECT IS COMPRESSED (WITH ZLIB) AND REFERENCED BY THE SHA-1 VALUE OF ITS CONTENTS PLUS A SMALL HEADER.

#+begin_quote
  ./              | *tree*: 1a738d
  -> test.cpp     | *blob*: a874b7
  -> README.md    | *blob*: a906cb
  -> lib/         | *tree*: fe8971
     -> test.lib  | *blob*: a0a60a
                    *commit*: a11bef
#+end_quote

+ THE BLOB

  In Git, the contents of files are stored as *blobs*.
  Git将文件的内容存储为Blob对象
  It is important to note that it is the contents that are stored, not the files. The names and modes of the files are not stored with the blob, just the contents.
  谨记它只是保存了文件的内容，文件的名字和属性并没有保存在Blob对象中。
  This means that if you have two files anywhere in your project that are exactly the same, even if they have different names, Git will only store the blob once. This also means that during repository transfers, such as clones or fetches, Git will only transfer the blob once, then expand it out into multiple files upon checkout.
  这就意味着如果你有两个内容相同的文件，即使他们的文件名不同，位置不同，Git只保存了一份Bolb数据在仓库里，当需要使用时，将他们解开成对应的文件。

+ The Tree
  Dictories in Git basically correspend to *trees*.
  A tree is a simple list of trees and blobs that the tree contains, along whit the names and modes of those trees and blobs. The contents section of a tree object consists of a very simple text file that lists the mode, type, name and sha of each entry.
  tree包含其目录下的其他目录tree及文件的blob信息,包含他们的name和mode.

+ The Commit
  So, now that we can store arbitrary trees of content in Git, where does the 'history' part of 'tree history storage system' come in? The answer is the *commit* object.
  The commit is very simple, much like the tree, It simply points to a tree and keeps an author, committer, message and any parent commits that directly preceded it.
  commit很简单，它和tree很相似，它只想特定的tree，同时包含了提交的作者，提交者，提交注释和直接与其关联的commit(父commit)。
  通常情况下一个commit只有一个parent commit，如果是从其他分支merge过来的，则可能出现多个parent commit信息

+ The Tag
  *Tag* is the final type of object you will find in a Git database. This is an object that provides a permanent shorthand name for a particular commit. It contains an object, type, tag, tagger and a message. Normally the type is *commit* and the object is the SHA-1 of the commit you're tagging. THe tag can also be GPG signed, providing cryptographic integrity to a release or version.
  Tag是Git对象的最后一个，他提供对特定commit的持久的引用，包含类型(commit), 对象(commit SHA-1 signature), tag(标签名称), message(标签的描述)及打标签的用户信息。


** The Git Data Model
Git objects are immutable - they cannot ever be changed. Reference can constantly change. They are simple pointers to a particular object.

Examples of references are *branchs* and *remotes*.
A branch in Git is nothing more than a file in the *.git/refs/heads/* directory that contains the SHA-1 of the most recent commit of that branch. To branch that line of development, all Git does is create a new file in that directory that points to the same SHA-1. As you continue to commit, one of the branches will keep changing to point to the new commit SHA-1s, while the other one can stay where it was.
Branch在Git中由 *.git/refs/heads/* 下的文件表现。当不断提交时，当前branch的commit指向新的commit的SHA-1，其他没有变化。


*** The Model
The basic data model I've been explaining looks something like this:
#+begin_quote
                     HEAD
                      |
          remote   branch   tag
               \      |      /
                    commit(loop)
                      |
                     tree(loop)
                     /|\
                     blob
#+end_quote
The cheap reference I've represented as HEAD, remote & branch.
The immutable objects are the tag, commit, tree & blob.

HEAD file points to the branch we're currently on, that help Git know which commit will be the parent for the next commit.

当提交时，新的commit被创建，
+ commit的parent指向当前HEAD对应的commit
+ 被改变的文件的blob被记录到它对应得tree下，包含此tree的tree也发生了变化，直到不再变化的tree
+ 如果此时我们创建tag, tag指向当前commit


*** Traversal


* Git commands

** basic command
*** creating an initial reposotory
**** git init
将当前目录初始化为Git Repository的根根目录，创建一个空的仓库

*** adding a file to your repository
**** git add fileName
将指定的文件或目录加入Git仓库，如果是目录，则会递归添加目录下所有内容(包含文件及所有子目录)

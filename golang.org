#+STARTUP: 
# 如何在emacs里输入中文，在/etc/profile 尾部增加
# LOCAL=zh_CN.UTF-8
# 重启电脑即可，前提是你的ibus已经可以正常工作了

* golang
read book <<The go program language>>

*** Package and Tools
Each package defines a distinct name space that encloses its identifiers.
Each name is associated with a particular package.
Choose short, clear names for the types, functions.

Packages provide encapsulation by controlling which names are visible or 
exported outside the package.
Restricting the visibility of package members hide the helper functions and
types behind the package's API, allowing the package maintainer to change the
implementation with confidence.

**** Import Paths
Each package is indentified by a unique string called its -import path-.
Import paths are the strings that appear in import declarations.
#+BEGIN_SRC golang
import (
    "fmt"
    "math/rand"
    "encoding/json"
    "golang.org/x/net/html"
    "github.com/go-sql-driver/mysql"
)
#+END_SRC
***** import paths should be globally unique
to avoid conflicts, the import paths of all packages other than those from
the standard library should start with *Internet domain name of the organization*
that owns or hosts the package.

**** The Package Declaration
A package declaration is required at the start of every Go source file.
Its main purpose is to determine the default identifier for that package 
(called the package name) when it imported by another package.

For example, every file of the math/rand package starts with package rand,
so when you import this package, you can access its members as rand.Int,
rand.Float64 and so on.
#+BEGIN_SRC golang
package main

import (
    "fmt"
    "math/rand"
)

func main() {
    fmt.Println(rand.Int())
}
#+END_SRC

Conventionally, the package name is *the last segment* of the import path,
and as a result, two packages may ave the same name even though their import
paths necessarily differ.

There are three major exceptions to the *last segment convention*.
1. A package defining a command (an executable Go program) always has the name *main*, regardless of the package's import path. *This is a singal to go build that it must invoke the linker to make an executable file*
2. Some files in the directory may have the suffix _test on their package name if the file name ends with *_test.go*. Such a directory may define two packages: the usual one, plus another one called an external test package. The *_test* suffix signals to go test that it must build both packages, and it indicates which files belong to each package. External test packages are used to avoid cycles in the import graph arising from dependencyies of the test.
3. Some tools for denpendency management append version number suffixes to package import paths, such as "gopkg.in/yaml.v2". The package name excludes the suffix, so in this case it would be just yaml.




**** Import Declarations
If you need to import two packages whose name are the same, like math/rand
and crypto/rand, to avoid name conflict, you can renaming import
#+BEGIN_SRC golang
import (
    "crypto/rand"
    mrand "math/rand" // alternative name mrand avoids conflict
)
#+END_SRC

**** Blank Imports
It is an error to import a package into a file but not refer to the name it defines 
within that file.
However, on occasion we must import a package merely for the side effects of doing so; evaluation of the initializer expressions of its package-level variables and execution of its init functions.
To suppress the "unused import" error we would otherwise encounter, we must use a renaming import in which the alternative name is *_*, *the blank identifier*, As usual, the blank identifier can never be referenced.
#+BEGIN_SRC golang
import _ "image/png" // register PNG decoder
#+END_SRC
The standard library's image package exports a Decode function that reads bytes 
from an io.Reader, figures out which image format was used to encode the data, 
invokes the appropriate decoder, then returns the resulting image.Image. 
Using image.Decode, it's easy to build a simple image converter that reads an image 
in one format and writes it out in another:
#+BEGIN_SRC golang
// The jpeg command reads a PNG image from the standard input
// and writes it as a JPEG image to the standard output
package main

import (
    "fmt"
    "image"
    "image/jpeg"
    _ "image/png" // register PNG decoder
    "io"
    "os"
)
#+END_SRC

the side effect of import "image/png" is to register PNG decoder in image/png package init() function
#+BEGIN_SRC golang
package png // image/img

func Decoder(r io.Reader) (image.Image, error)
func DecodeConfig(r io.Reader) (image.Config, error)

func init() {
    const pngHeader = "\x89PNG\r\n\x1a\n"
    image.RegisterFormat("png", pngHeader, Decoder, DecodeConfig)
}
#+END_SRC
The image.Decode function consults a table of supported formats. Each entry 
in the table specifies four things: 
1. the *name* of the format
2. a *string* that is a prefix of all images encoded this way
3. a function *Decoder* that decodes an encoded image
4. another function *DecodeConfig* that decodes only the image metadata, such as its size and color space.
An entry is added to the table by calling *image.RegisterFormat*


**** PACKAGES and Naming


** golang 基础部分 <<学习Golang>> <2016-04-01 Fri 00:03>

*** 数据类型
**** array
array 定义方式为 *[n]<type>*, *n* 表示array的长度,type表示存储内容的类型. 
大小是类型的一部分,不同的大小是不同的类型,不能赋值.
*Notice* 数组是 *值* 类型,将一个数组传递给函数,函数将获得数组的一份拷贝.

数组的初始化及多维数组
#+begin_src, golang
var a [10]int // 默认初始化为0
a = {1,2,3,4,5,6,7,8,9,0}  // 一维数组,
b := [3][2]int{ [...]int{1,2}, [2]int{3,4}, [2]int{5,6}}  // 二维数组,3行2列, [...]是老版本的填充写法,自动得到数组大小也要在方括号中填东西, 新版本不需要
c := [3][2]int{ {1,2}, {3,4}, {5,6} }  // 同 b
d := []int{1,2,3,4,5,6,7,8,9,0}  // 同 a,自动推倒出大小
#+end_src


**** slice
slice与array接近,它是array的一个指针,底层指向一个array.
slice是 *引用* 类型,对slice赋值时可能使它指向其他的array.
slice作为函数的参数传递时,对slice内容的修改将传递回调用者,因为它是 *引用* 类型.相当于传递了底层array的指针.


slice 使用 *make([]<type>, capicity)* 方式创建, make的第一个参数类似与array声明,第二参数表示要创建的底层array的容量.
slice 也可通过对array/slice的切片操作创建, 切片操作 *array[n:m]* 其中 *n* 是起始下标,默认为0, *m* 结束下标,默认为被切片对象的最大下标.
如果切片操作的上下标超出被切片对象的范围,会产生运行时错误.

#+begin_src, golang
var array [10]int
slice := array[0:5]  // 将array作为slice的底层array,slice的len == 5, cap == 10
#+end_src

***** append slice
使用 append(slice, ...) 在slice末尾追加元素,当追加数量超过底层array容量时,append自动分配新的底层array,并将旧值赋值过来,在进行追加操作. 操作完成后slice的底层array已经变化.
append(slice, slice...)  如果追加的是slice, 需要带 *...* 告诉append将其展开


**** map
map是hash表(有索引的数组),定义map的格式为 *map[<from type>]<to type>*
map也是 *引用* 类型
#+begin_src, golang
monthidays := map[string]int{
    "Jan": 31, "Feb":28, "Mar": 31, // 最后的,是必须的
}
aMap := make(map[string]int)
#+end_src

map索引使用方括号检索
对map使用range函数返回 key,value 对
检查元素是否存在,用并行赋值
#+begin_src, golang
val, present := monthdays["Jul"]
// 如果 "Jul" 索引存在,val为其值,present == true
// 否则 val is nil, present == false

delete(monthdays, "Mar")  // 删除map中的特定索引及值
#+end_src


*** 函数 <2016-04-01 五 17:21>

定义函数
#+begin_src, golang
type mytype int  // 新的类型

func (p mytype) funcname(q int) (r,s int) { return 0,0 }

#+end_src
+ 关键字 *func* 用于定义一个函数
+ 函数可以绑定到特定类型上. 叫做 *接收者*. 有 *接收者* 的函数叫做 *mehtod* 方法. 
+ *funcname* 是函数名
+ q 是 int 类型的参数,值类型的参数使用 pass-by-value 方式传递,被复制
+ r, s 是函数的命名返回值. 如果返回一个值,可以省略()


+ go不允许函数嵌套,但可以嵌套匿名函数.
+ 局部变量覆盖全局变量


**** 命名返回值
go函数可以返回多个值,命名返回值的特点是
+ 命名返回值可作为局部变量在函数内使用
+ 命名返回值默认被初始化为对应类型的nil值
+ 函数执行 return 语句不带任何参数,命名返回值的当前值会被返回
+ 名字不是强制的,但是好的名字可以增加代码的可读性


**** 延迟代码
延迟代码会在函数退出前被调用,使用 *defer* 指定延迟代码.
延迟代码的可用于释放在函数中申请的资源,防止在函数退出时忘记释放或释放多次.
可多次使用 *defer* 指定延迟代码, 被延迟的代码按照 *FILO/LIFO* 的顺序执行.
也可以用 *defer* 调用匿名函数
#+begin_src, golang
func deferDemo(x int) (y int) {
    defer func() {  // 匿名函数
        fmt.Println("deferDemo will return!")
        y = 10 // always return 10
    }()  // 此处的()是必须的,表示调用函数
    
    defer func(x int) {  // 带参数的匿名函数
        y = x  // 修改返回值
    }(5)  // 调用函数并提供参数
}
#+end_src


**** 变参
接受不定参数的函数叫做变参函数.
func myfunc(arg ...int) {}
*arg ...int* 表示接受不定个数的 int 类型参数,在函数体中,arg是int类型的slice
如果不指定参数的类型,默认是空接口 interface{}.

#+begin_src, golang
func myfunc(arg ...int) {
    for k, v := range arg {
        fmt.Println("param[%d] == %d", k, v)
    }
}

func myfuncX(arg ...) {  // 默认类型为interface{}
}
#+end_src


**** 函数作为值
函数在golang中也是值,可以被赋值
可以将函数作为参数传递给函数,函数是 *引用* 类型(废话 bull ^o^)
函数作为参数时,要说明函数的参数及返回值,不需要提供函数名: *func(parameter list) (ret list)* 作为函数签名
使用 *%T* 打印类型,函数将输出 *func()*

#+begin_src, golang
func main() {
    a := func() {  // 匿名函数赋值给a
        println("I am a anonymous function")
    }
}

var xs = map[int]func() int{}  // xs是一个数字和函数的hash
xs[1] = func() int { return 1 }
xs[2] = func() int { return 2 }

func myfunc(a int, b int, c ...int) (ret ...int) {
    append(ret, a)
    append(ret, b)
    append(ret, c...)
}

func callback(a int, f func(int, int, ...int) (...int)) {
   x := make([]int, 1)
   y := f(a, 1, x)
   for k, v := range y {
       println("k[%d]: v:[%d]", k, v)
   }
}

#+end_src


**** 恐慌(Panic)和恢复(Recover)
恐慌和恢复是golang的异常处理机制.
它应当被视为是最后的手段来使用.

***** 恐慌(Panic)
是一个内建的函数,可以中断原有的控制流程,进入一个恐慌流程.
恐慌流程使调用函数的的执行被中断, *但此函数的延迟函数可以正常执行*.
之后会返回调用者,调用者也会执行相同的恐慌行为,中断执行,执行其延迟函数.
*恐慌使用这种方式向上传递,直到所有gorountine返回或遇到recover*.

使用 *panic* 人为产生恐慌,可以由运行时错误产生,如数组越界

***** 恢复(Recover)
是一个函数,可以让进入恐慌流程的goroutine恢复.
*recover仅在延迟函数中有效*
正常情况下,recover调用会返回nil并且没有任何其他效果.
如果goroutine进入恐慌,recover调用将返回panic输入的值,并恢复正常执行.

#+begin_src, golang
func catchPanic(f func()) (b bool) {
    defer func() {  // 延迟函数
        if x := recover(); x != nil {
            b = true
        }
    }()  // 调用的()不能少
    f()
}
#+end_src
通过catchPanic函数调用的函数的panic不会传递到调用catchPanic的函数中.
f函数的panic的传递在catchPanic中被终止.




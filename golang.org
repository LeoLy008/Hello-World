#+STARTUP: indent
# 如何在emacs里输入中文，在/etc/profile 尾部增加
# LOCAL=zh_CN.UTF-8
# 重启电脑即可，前提是你的ibus已经可以正常工作了

* golang
read book <<The go program language>>

*** Package and Tools
Each package defines a distinct name space that encloses its identifiers.
Each name is associated with a particular package.
Choose short, clear names for the types, functions.

Packages provide encapsulation by controlling which names are visible or 
exported outside the package.
Restricting the visibility of package members hide the helper functions and
types behind the package's API, allowing the package maintainer to change the
implementation with confidence.

**** Import Paths
Each package is indentified by a unique string called its -import path-.
Import paths are the strings that appear in import declarations.
#+BEGIN: golang
import (
    "fmt"
    "math/rand"
    "encoding/json"
    "golang.org/x/net/html"
    "github.com/go-sql-driver/mysql"
)
#+END
***** import paths should be globally unique
to avoid conflicts, the import paths of all packages other than those from
the standard library should start with *Internet domain name of the organization*
that owns or hosts the package.

**** The Package Declaration
A package declaration is required at the start of every Go source file.
Its main purpose is to determine the default identifier for that package 
(called the package name) when it imported by another package.

For example, every file of the math/rand package starts with package rand,
so when you import this package, you can access its members as rand.Int,
rand.Float64 and so on.
#+BEGIN: golang
package main

import (
    "fmt"
    "math/rand"
)

func main() {
    fmt.Println(rand.Int())
}
#+END

Conventionally, the package name is *the last segment* of the import path,
and as a result, two packages may ave the same name even though their import
paths necessarily differ.

There are three major exceptions to the *last segment convention*.
1. A package defining a command (an executable Go program) always has the name *main*, regardless of the package's import path. *This is a singal to go build that it must invoke the linker to make an executable file*
2. Some files in the directory may have the suffix _test on their package name if the file name ends with *_test.go*. Such a directory may define two packages: the usual one, plus another one called an external test package. The *_test* suffix signals to go test that it must build both packages, and it indicates which files belong to each package. External test packages are used to avoid cycles in the import graph arising from dependencyies of the test.
3. Some tools for denpendency management append version number suffixes to package import paths, such as "gopkg.in/yaml.v2". The package name excludes the suffix, so in this case it would be just yaml.




**** Import Declarations
If you need to import two packages whose name are the same, like math/rand
and crypto/rand, to avoid name conflict, you can renaming import
#+BEGIN: golang
import (
    "crypto/rand"
    mrand "math/rand" // alternative name mrand avoids conflict
)
#+END

**** Blank Imports
It is an error to import a package into a file but not refer to the name it defines 
within that file.
However, on occasion we must import a package merely for the side effects of doing so; evaluation of the initializer expressions of its package-level variables and execution of its init functions.
To suppress the "unused import" error we would otherwise encounter, we must use a renaming import in which the alternative name is *_*, *the blank identifier*, As usual, the blank identifier can never be referenced.
#+BEGIN: golang
import _ "image/png" // register PNG decoder
#+END
The standard library's image package exports a Decode function that reads bytes 
from an io.Reader, figures out which image format was used to encode the data, 
invokes the appropriate decoder, then returns the resulting image.Image. 
Using image.Decode, it's easy to build a simple image converter that reads an image 
in one format and writes it out in another:
#+BEGIN: golang
// The jpeg command reads a PNG image from the standard input
// and writes it as a JPEG image to the standard output
package main

import (
    "fmt"
    "image"
    "image/jpeg"
    _ "image/png" // register PNG decoder
    "io"
    "os"
)
#+END

the side effect of import "image/png" is to register PNG decoder in image/png package init() function
#+BEGIN: golang
package png // image/img

func Decoder(r io.Reader) (image.Image, error)
func DecodeConfig(r io.Reader) (image.Config, error)

func init() {
    const pngHeader = "\x89PNG\r\n\x1a\n"
    image.RegisterFormat("png", pngHeader, Decoder, DecodeConfig)
}
#+END
The image.Decode function consults a table of supported formats. Each entry 
in the table specifies four things: 
1. the *name* of the format
2. a *string* that is a prefix of all images encoded this way
3. a function *Decoder* that decodes an encoded image
4. another function *DecodeConfig* that decodes only the image metadata, such as its size and color space.
An entry is added to the table by calling *image.RegisterFormat*


**** PACKAGES and Naming

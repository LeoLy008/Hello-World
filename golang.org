#+STARTUP: 
# 如何在emacs里输入中文，在/etc/profile 尾部增加
# LOCAL=zh_CN.UTF-8
# 重启电脑即可，前提是你的ibus已经可以正常工作了

* golang
read book <<The go program language>>

*** Package and Tools
Each package defines a distinct name space that encloses its identifiers.
Each name is associated with a particular package.
Choose short, clear names for the types, functions.

Packages provide encapsulation by controlling which names are visible or 
exported outside the package.
Restricting the visibility of package members hide the helper functions and
types behind the package's API, allowing the package maintainer to change the
implementation with confidence.

**** Import Paths
Each package is indentified by a unique string called its -import path-.
Import paths are the strings that appear in import declarations.
#+BEGIN_SRC golang
import (
    "fmt"
    "math/rand"
    "encoding/json"
    "golang.org/x/net/html"
    "github.com/go-sql-driver/mysql"
)
#+END_SRC
***** import paths should be globally unique
to avoid conflicts, the import paths of all packages other than those from
the standard library should start with *Internet domain name of the organization*
that owns or hosts the package.

**** The Package Declaration
A package declaration is required at the start of every Go source file.
Its main purpose is to determine the default identifier for that package 
(called the package name) when it imported by another package.

For example, every file of the math/rand package starts with package rand,
so when you import this package, you can access its members as rand.Int,
rand.Float64 and so on.
#+BEGIN_SRC golang
package main

import (
    "fmt"
    "math/rand"
)

func main() {
    fmt.Println(rand.Int())
}
#+END_SRC

Conventionally, the package name is *the last segment* of the import path,
and as a result, two packages may ave the same name even though their import
paths necessarily differ.

There are three major exceptions to the *last segment convention*.
1. A package defining a command (an executable Go program) always has the name *main*, regardless of the package's import path. *This is a singal to go build that it must invoke the linker to make an executable file*
2. Some files in the directory may have the suffix _test on their package name if the file name ends with *_test.go*. Such a directory may define two packages: the usual one, plus another one called an external test package. The *_test* suffix signals to go test that it must build both packages, and it indicates which files belong to each package. External test packages are used to avoid cycles in the import graph arising from dependencyies of the test.
3. Some tools for denpendency management append version number suffixes to package import paths, such as "gopkg.in/yaml.v2". The package name excludes the suffix, so in this case it would be just yaml.




**** Import Declarations
If you need to import two packages whose name are the same, like math/rand
and crypto/rand, to avoid name conflict, you can renaming import
#+BEGIN_SRC golang
import (
    "crypto/rand"
    mrand "math/rand" // alternative name mrand avoids conflict
)
#+END_SRC

**** Blank Imports
It is an error to import a package into a file but not refer to the name it defines 
within that file.
However, on occasion we must import a package merely for the side effects of doing so; evaluation of the initializer expressions of its package-level variables and execution of its init functions.
To suppress the "unused import" error we would otherwise encounter, we must use a renaming import in which the alternative name is *_*, *the blank identifier*, As usual, the blank identifier can never be referenced.
#+BEGIN_SRC golang
import _ "image/png" // register PNG decoder
#+END_SRC
The standard library's image package exports a Decode function that reads bytes 
from an io.Reader, figures out which image format was used to encode the data, 
invokes the appropriate decoder, then returns the resulting image.Image. 
Using image.Decode, it's easy to build a simple image converter that reads an image 
in one format and writes it out in another:
#+BEGIN_SRC golang
// The jpeg command reads a PNG image from the standard input
// and writes it as a JPEG image to the standard output
package main

import (
    "fmt"
    "image"
    "image/jpeg"
    _ "image/png" // register PNG decoder
    "io"
    "os"
)
#+END_SRC

the side effect of import "image/png" is to register PNG decoder in image/png package init() function
#+BEGIN_SRC golang
package png // image/img

func Decoder(r io.Reader) (image.Image, error)
func DecodeConfig(r io.Reader) (image.Config, error)

func init() {
    const pngHeader = "\x89PNG\r\n\x1a\n"
    image.RegisterFormat("png", pngHeader, Decoder, DecodeConfig)
}
#+END_SRC
The image.Decode function consults a table of supported formats. Each entry 
in the table specifies four things: 
1. the *name* of the format
2. a *string* that is a prefix of all images encoded this way
3. a function *Decoder* that decodes an encoded image
4. another function *DecodeConfig* that decodes only the image metadata, such as its size and color space.
An entry is added to the table by calling *image.RegisterFormat*


**** PACKAGES and Naming


** golang 基础部分 <<学习Golang>> <2016-04-01 Fri 00:03>

*** 数据类型
**** array
array 定义方式为 *[n]<type>*, *n* 表示array的长度,type表示存储内容的类型. 
大小是类型的一部分,不同的大小是不同的类型,不能赋值.
*Notice* 数组是 *值* 类型,将一个数组传递给函数,函数将获得数组的一份拷贝.

数组的初始化及多维数组
#+begin_src, golang
var a [10]int // 默认初始化为0
a = {1,2,3,4,5,6,7,8,9,0}  // 一维数组,
b := [3][2]int{ [...]int{1,2}, [2]int{3,4}, [2]int{5,6}}  // 二维数组,3行2列, [...]是老版本的填充写法,自动得到数组大小也要在方括号中填东西, 新版本不需要
c := [3][2]int{ {1,2}, {3,4}, {5,6} }  // 同 b
d := []int{1,2,3,4,5,6,7,8,9,0}  // 同 a,自动推倒出大小
#+end_src

**** slice
slice与array接近,它是array的一个指针,底层指向一个array.
slice是 *引用* 类型,对slice赋值时可能使它指向其他的array.
slice作为函数的参数传递时,对slice内容的修改将传递回调用者,因为它是 *引用* 类型.相当于传递了底层array的指针.


slice 使用 *make([]<type>, capicity)* 方式创建, make的第一个参数类似与array声明,第二参数表示要创建的底层array的容量.
slice 也可通过对array/slice的切片操作创建, 切片操作 *array[n:m]* 其中 *n* 是起始下标,默认为0, *m* 结束下标,默认为被切片对象的最大下标.
如果切片操作的上下标超出被切片对象的范围,会产生运行时错误.

#+begin_src, golang
var array [10]int
slice := array[0:5]  // 将array作为slice的底层array,slice的len == 5, cap == 10
#+end_src

***** append slice
使用 append(slice, ...) 在slice末尾追加元素,当追加数量超过底层array容量时,append自动分配新的底层array,并将旧值赋值过来,在进行追加操作. 操作完成后slice的底层array已经变化.
append(slice, slice...)  如果追加的是slice, 需要带 *...* 告诉append将其展开


**** map
map是hash表(有索引的数组),定义map的格式为 *map[<from type>]<to type>*
map也是 *引用* 类型
#+begin_src, golang
monthidays := map[string]int{
    "Jan": 31, "Feb":28, "Mar": 31, // 最后的,是必须的
}
aMap := make(map[string]int)
#+end_src

map索引使用方括号检索
对map使用range函数返回 key,value 对
检查元素是否存在,用并行赋值
#+begin_src, golang
val, present := monthdays["Jul"]
// 如果 "Jul" 索引存在,val为其值,present == true
// 否则 val is nil, present == false

delete(monthdays, "Mar")  // 删除map中的特定索引及值
#+end_src